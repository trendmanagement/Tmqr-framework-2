.. _framework-introduction:

===================================
Framework introduction (start here)
===================================

:ref:`index-page`

.. toctree::
:maxdepth: 2

Introduction
++++++++++++
This framework has been designed to be as developer friendly as possible. As a developer you should learn and master few
concepts which will help you to build Indexes and Alphas using full strength of tools.

Data and position
~~~~~~~~~~~~~~~~~
To become fluent in the framework's indexes and alphas development you have to master only 2 core classes.

* All aspects of data management are build based on Pandas package, typically all quotes and price series are `Pandas.DataFrames <https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html>`_
  All access to data is provided by :ref:`datamanager-class`, probably this is a core of entire framework.

* All indexes and alphas are using :ref:`position-class` to build, manage and make calculations.



DataManager
+++++++++++

The class which is manages everything. You can always refer to autogenerated information about :ref:`datamanager-class`.

In this section you will find description of common DataManager applications.

There are 2 phases of DataManager usage:
    1. Initialization phase - usually in ``setup()`` method of index or alpha class, in this phase you have to set up
       asset trading session, set up costs, and finally set the quotes up.
    2. Runtime phase - after setup you can fetch quotes series from datamanager for quantitative analysis, and get pre-loaded
       positions of Quote* algorithms or indexes, also you can fetch future and options contracts from chains and use them
       in position construction process.



Setting quotes series
~~~~~~~~~~~~~~~~~~~~~
The main purpose of the DataManager class is to get the quotes data for particular instrument or index from the DB.
There are 2 main ways to set the data ``datamanager.series_primary_set(...)`` and ``series_extra_set(...)``. Primary series
are used for initiation of data series, you **must call** ``series_primary_set(...)`` every time, because datetime series of
primary quotes is used as anchor for extra series (a.k.a. secondary series) or position calculation.

To set up primary quotes you have to use one of the :ref:`quote-modules` by the following way::

    # To set continuous futures index for 'US.ES' instrument with decision_time_shift (for index usage)
    self.dm.series_primary_set(QuoteContFut, 'US.ES', timeframe='D')
                               # decision_time_shift=self.decision_time_shift) # This setting is optional for alphas and required for indexes!


    # To set pre-saved index series as primary quotes and series
    self.dm.series_primary_set(QuoteIndex, "US.ES_ContFut", set_session=True, check_session=True)


To set up secondary quotes you have to call series_extra_set(...) with one of the :ref:`quote-modules`, also you need
to define key-name for secondary quotes series that will be used for quotes access later::

    # To set continuous futures index for 'US.CL' instrument with decision_time_shift (for index usage)
    self.dm.series_extra_set('secondary_future_key_name', QuoteContFut, 'US.CL', timeframe='D')
                             # decision_time_shift=self.decision_time_shift) # This setting is optional for alphas and required for indexes!

    # To set pre-saved index series as secondary quotes and series
    self.dm.series_extra_set('secondary_index_key_name', QuoteIndex, "US.ES_Fancy_SmartEXO_Index", set_session=True, check_session=True)



.. note:: * You must always define ``datamanager.series_primary_set(...)``
* You must always call ``datamanager.session_set()`` before quotes initiation
          * Extra (a.k.a. secondary) series already aligned to the primary series by date
          * You must define ``decision_time_shift`` argument when you are working on index, and mustn't in case of alpha development
          * Typically you can access DataManager class for index or alpha by calling self.dm.<some_method(..)>

Getting quotes series
~~~~~~~~~~~~~~~~~~~~~
When primary and secondary (a.k.a. extra) quotes have been set somewhere in the ``setup()`` method of index or alphas, you
would be able to access these quotes to perform calculations, both series can be fetched by calling ``datamanager.quotes(series_key=None)`` method,
where **series_key=** is a extra series key defined at ``series_extra_set(...)``.

Examples based on quotes settings above::

    # Typically you can access DataManager class for index or alpha by calling self.dm.<some_method(..)>
    es_future_primary = self.dm.quotes()
    es_future_primary_alternative = self.dm.quotes(series_key=None)

    # Getting secondary data
    secondary_future_cl = self.dm.quote(series_key='secondary_future_key_name')
    secondary_pre_saved_index = self.dm.quote('secondary_index_key_name') # You can omit series_key=

    # These series above are Pandas.DataFrames
    # You have to access by column name to get OHLCV for QuoteContFut based results
    open_price = es_future_primary['o']
    high_price = es_future_primary['h']
    low_price = es_future_primary['l']
    close_price = es_future_primary['c']

    # For quotes produces by Index it's more complicated
    # There is no naming conventions for index columns

    # For positional indexes like EXOs/SmartEXOs column names should be
    # 'costs',
    # 'ncontracts_executed',
    # 'noptions_executed',
    # 'pnl_change_decision',
    # 'pnl_change_execution',
    # 'equity_decision',
    # 'equity_execution'

    # It's recommended to use 'equity_decision' for decision making in alphas
    index_price = secondary_pre_saved_index['equity_execution']


Getting positions
~~~~~~~~~~~~~~~~~
When you call ``datamanager.series_primary_set(...)`` or ``series_extra_set(...)`` Quote* algorithms also calculate the
underlying position of Quotes* series, for example QuoteContFut position represents holdings of actual front month future
contract and valid roll over trades to maintain the position. QuoteIndex algorithm's position will contain full EXO/SmartEXO
structure as well.

Foe example, this flexible position getting allow you to implement alphas which rebalancing between different types of EXO indexes.

The position getting API is very similar to quotes, just call ``datamanager.position(position_key=None)``::

Example based on positions settings above::

    # Typically you can access DataManager class for index or alpha by calling self.dm.<some_method(..)>
    es_future_primary_position = self.dm.position()
    es_future_primary_position = self.dm.position(position_key=None)

    # Getting secondary data
    secondary_future_cl_position = self.dm.position(position_key='secondary_future_key_name')
    secondary_pre_saved_index_position = self.dm.position('secondary_index_key_name') # You can omit position_key=


Setting session parameters
~~~~~~~~~~~~~~~~~~~~~~~~~~
Asset sessions are used for building quotes and position arrangement. Typically every instrument in TMQR framework 1.0 has
own session settings. Usually you need to use instrument name to set the session up, but in case when you need to build
multi-instrument index you have to set custom session setting to align all instruments' quotes to common timeline.

Setting session is required every time when you are going to use DataManager Quote* engine, you should set session before
setting the quotes by calling ``datamanager.series_primary_set(...)`` and ``series_extra_set(...)``.

To get more information refer to :meth:`tmqrfeed.manager.DataManager.session_set` help.

Examples::

    # Setting instrument specific session
    self.dm.session_set("US.ES")
    self.dm.session_set(instrument="US.ES")

    # Setting custom session (for spread index)
    session_settings = [
                    # Default session
                    {
                    'decision': '10:40',             # Decision time (uses 'tz' param time zone!)
                    'dt': datetime(1900, 12, 31),    # Actual date of default session start
                    'execution': '10:45',            # Execution time (uses 'tz' param time zone!)
                    'start': '03:32'                 # Start of the session time (uses 'tz' param time zone!)
                    },

                    # If session rules has been changed by exchange, you can set different rules
                    {
                    'decision': '11:40',             # Decision time (uses 'tz' param time zone!)
                    'dt': datetime(2010, 12, 31),    # Actual date of new session rules start
                    'execution': '11:45',            # Execution time (uses 'tz' param time zone!)
                    'start': '01:32'                 # Start of the session time (uses 'tz' param time zone!)
                    },
                ]

    # Timezone names list https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
    self.dm.session_set(session_list=session_settings, tz='US/Pacific')


Setting costs
~~~~~~~~~~~~~
Costs are required to calculate Index or Alpha positions, typically costs are set in ``setup()`` method. Sometimes you need
just to set costs values as parameters of the index or alpha, sometimes you will have to set the costs manually.

Example::

    from tmqrfeed import Costs

    #... somewhere in setup() method of Index or Alpha call


    # Setting costs per future contract and option
    self.dm.costs_set('US', Costs(per_contract=3.0, per_option=3.0))

    # Setting default costs (i.e. zero costs)
    self.dm.costs_set('US', Costs())

.. note:: * Costs are set on per-market basis
* Setting costs it required any time when you are developing index or alpha


Chains getting
~~~~~~~~~~~~~~
You can fetch 2 types of chains from DataManager:
    1. Futures chains getting mechanism allows you to select any future contract you want, you are free to fetch any
       instrument available in the DB. Refer to :meth:`tmqrfeed.manager.DataManager.chains_futures_get` to get more information.

        Example::

            # Getting front month ES future
            es_front_future = self.dm.chains_futures_get('US.ES', dt, offset=0)

            # Getting next month CL future
            cl_next_future = self.dm.chains_futures_get('US.CL', dt, offset=1)

    2. You can get future + option chain pair if you need to initiate complex future + options position. Refer to
       :meth:`tmqrfeed.manager.DataManager.chains_options_get` to get more information (**pay more attention** to kwarg parameters).

        Example::

            # Getting front option and underlying future
            fut, opt_chain = self.dm.chains_options_get('US.ES', dt)

            # Getting front + 2 option contract and underlying future
            fut_next, opt_chain_next = self.dm.chains_options_get('US.ES', dt, opt_offset=2)

        .. note:: * Refer to documentation of 'fut' part of return value :class:`tmqrfeed.contracts.FutureContract`
* Refer to documentation of 'opt_chain' part of return value :class:`tmqrfeed.chains.OptionChain` (**pay more attention** to **find** method!)


Position
++++++++
Position concept is a foundation of the framework, EXO index series are build on position's PnL, alphas equity lines are
also produced by position calculations. General reference of :ref:`position-class`

You can build position in 3 different ways:
    1. You can replicate position of :ref:`quote-modules` or index inside developed index or alpha
    2. You can build your own position by adding transactions to the position
    3. You can mix both approaches, at the first step you can replicate index position, then check it's delta and hedge
       it by adding future transaction.


Position replication
~~~~~~~~~~~~~~~~~~~~
For example you would like to replicate index position, in your alpha::

    def setup(self):
        #...

        self.dm.series_extra_set('secondary_index_key_name', QuoteIndex, "US.ES_Fancy_SmartEXO_Index", set_session=True, check_session=True)


    def calculate_position(self, date: datetime, exposure_record: pd.DataFrame):
        # This is main position management method for alphas

        # Getting the index's position
        index_position = self.dm.position('secondary_index_key_name')

        # Getting position records at particular date
        replicated_pos = index_position.get_net_position(date)

        # Setting position of alpha to replicated position
        # qty= means N-units times index position
        self.position.add_net_position(date, replicated_pos, qty=2.0)

.. note:: Position replication methods:

 * :meth:`tmqrfeed.position.Position.add_net_position`
 * :meth:`tmqrfeed.position.Position.get_net_position`
 * :meth:`tmqrfeed.position.Position.set_net_position`

Position construction
~~~~~~~~~~~~~~~~~~~~~
In case of EXO index building you have probably wanted to build custom position to implement some sort of option model.

To do this you have to be familiar with datamanger chains fetching by :meth:`tmqrfeed.manager.DataManager.chains_options_get`
and :meth:`tmqrfeed.chains.OptionChain.find()` method usage.

Example::

    def construct_position(self, dt, pos, logic_df):
        """
        EXO position construction method
        :param dt: current datetime
        :param pos: Position instance
        :param logic_df: result of calc_exo_logic()[dt]  if applicable
        :return: nothing, manages 'pos' in place
        """

        # Getting future contract and option chain
        fut, opt_chain = self.dm.chains_options_get(self.instrument, dt)

        # Selling 5.0 ATM Put options
        pos.add_transaction(dt, opt_chain.find(dt, 0, 'P'), -5.0)

.. note:: Position management and other related methods:

 * :meth:`tmqrfeed.manager.DataManager.chains_options_get`
 * :meth:`tmqrfeed.chains.OptionChain.find`
 * :meth:`tmqrfeed.position.Position.add_transaction`
 * :meth:`tmqrfeed.position.Position.close`
 * :meth:`tmqrfeed.position.Position.keep_previous_position`


Position information
~~~~~~~~~~~~~~~~~~~~
* :meth:`tmqrfeed.position.Position.has_position` - position existence check at particular date
* :meth:`tmqrfeed.position.Position.delta` - calculates position delta
* :meth:`tmqrfeed.position.Position.almost_expired_ratio` - return the fraction of contracts in the position 'rollover_days_before' near expiration
* :meth:`tmqrfeed.position.Position.last_date` - last date of the position
* :meth:`tmqrfeed.position.Position.last_transaction_date` - last transaction date of the position